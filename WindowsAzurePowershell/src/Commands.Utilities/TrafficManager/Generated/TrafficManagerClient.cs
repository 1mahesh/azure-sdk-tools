// 
// Copyright (c) Microsoft and contributors.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// 
// See the License for the specific language governing permissions and
// limitations under the License.
// 

// Warning: This code was generated by a tool.
// 
// Changes to this file may cause incorrect behavior and will be lost if the
// code is regenerated.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.Common;
using Microsoft.WindowsAzure.Common.Internals;
using Microsoft.WindowsAzure.Management.TrafficManager;
using Microsoft.WindowsAzure.Management.TrafficManager.Models;

namespace Microsoft.WindowsAzure.Management.TrafficManager.Models
{
    /// <summary>
    /// Describes a definition.
    /// </summary>
    public partial class Definition
    {
        private DefinitionDnsOptions _dnsOptions;
        
        /// <summary>
        /// Optional. The DNS related option.
        /// </summary>
        public DefinitionDnsOptions DnsOptions
        {
            get { return this._dnsOptions; }
            set { this._dnsOptions = value; }
        }
        
        private IList<DefinitionMonitor> _monitors;
        
        /// <summary>
        /// Optional. The list of Endpoint monitoring configurations.
        /// </summary>
        public IList<DefinitionMonitor> Monitors
        {
            get { return this._monitors; }
            set { this._monitors = value; }
        }
        
        private DefinitionPolicyResponse _policy;
        
        /// <summary>
        /// Optional. The Endpoint monitoring policy.
        /// </summary>
        public DefinitionPolicyResponse Policy
        {
            get { return this._policy; }
            set { this._policy = value; }
        }
        
        private ProfileDefinitionStatus _status;
        
        /// <summary>
        /// Optional. Indicates whether this definition is enabled or disabled
        /// for the profile.
        /// </summary>
        public ProfileDefinitionStatus Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        private int _version;
        
        /// <summary>
        /// Optional. Indicates the version of the definition returned. This
        /// value is always 1.
        /// </summary>
        public int Version
        {
            get { return this._version; }
            set { this._version = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the Definition class.
        /// </summary>
        public Definition()
        {
            this._monitors = new List<DefinitionMonitor>();
        }
    }
    
    /// <summary>
    /// Parameters supplied to create a definition.
    /// </summary>
    public partial class DefinitionCreateParameters
    {
        private DefinitionDnsOptions _dnsOptions;
        
        /// <summary>
        /// Required.
        /// </summary>
        public DefinitionDnsOptions DnsOptions
        {
            get { return this._dnsOptions; }
            set { this._dnsOptions = value; }
        }
        
        private IList<DefinitionMonitor> _monitors;
        
        /// <summary>
        /// Required.
        /// </summary>
        public IList<DefinitionMonitor> Monitors
        {
            get { return this._monitors; }
            set { this._monitors = value; }
        }
        
        private DefinitionPolicyCreateParameters _policy;
        
        /// <summary>
        /// Required.
        /// </summary>
        public DefinitionPolicyCreateParameters Policy
        {
            get { return this._policy; }
            set { this._policy = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DefinitionCreateParameters class.
        /// </summary>
        public DefinitionCreateParameters()
        {
            this._monitors = new List<DefinitionMonitor>();
        }
    }
    
    /// <summary>
    /// DNS related option.
    /// </summary>
    public partial class DefinitionDnsOptions
    {
        private int _timeToLiveInSeconds;
        
        /// <summary>
        /// Required. Specifies the DNS Time-to-Live (TTL) that informs the
        /// Local DNS resolvers how long to cache DNS entries. The value is an
        /// integer from 30 through 999,999.
        /// </summary>
        public int TimeToLiveInSeconds
        {
            get { return this._timeToLiveInSeconds; }
            set { this._timeToLiveInSeconds = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DefinitionDnsOptions class.
        /// </summary>
        public DefinitionDnsOptions()
        {
        }
    }
    
    /// <summary>
    /// Specifies an Endpoint configuration
    /// </summary>
    public partial class DefinitionEndpointCreateParameters
    {
        private string _domainName;
        
        /// <summary>
        /// Required. Specifies the endpoint domain name.
        /// </summary>
        public string DomainName
        {
            get { return this._domainName; }
            set { this._domainName = value; }
        }
        
        private string _location;
        
        /// <summary>
        /// Optional. Specifies the location of an endpoint of type "Any". This
        /// is required for Performance policies. A list of possible values
        /// can be found under "Name" by calling List Locations:
        /// http://msdn.microsoft.com/en-us/library/gg441293.aspx
        /// </summary>
        public string Location
        {
            get { return this._location; }
            set { this._location = value; }
        }
        
        private EndpointStatus _status;
        
        /// <summary>
        /// Required. Specifies the status of the monitoring endpoint. If set
        /// to Enabled, the endpoint is considered by the load balancing
        /// method and is monitored.
        /// </summary>
        public EndpointStatus Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        private EndpointType _type;
        
        /// <summary>
        /// Optional. The type of endpoint being added to the definition. If
        /// there is more than one AzureWebsite endpoint, they must be in
        /// different datacenters. This limitation doesnâ€™t apply to cloud
        /// services. The default value is "CloudService".
        /// </summary>
        public EndpointType Type
        {
            get { return this._type; }
            set { this._type = value; }
        }
        
        private int _weight;
        
        /// <summary>
        /// Optional. Specifies the weight of an endpoint in a weighted round
        /// robin policy. The valid range is for this value is [1, 1000]. The
        /// default is 1.
        /// </summary>
        public int Weight
        {
            get { return this._weight; }
            set { this._weight = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// DefinitionEndpointCreateParameters class.
        /// </summary>
        public DefinitionEndpointCreateParameters()
        {
        }
    }
    
    public enum DefinitionEndpointMonitorStatus
    {
        Online = 0,
        
        Degraded = 1,
        
        Inactive = 2,
        
        Disabled = 3,
        
        Stopped = 4,
        
        CheckingEndpoint = 5,
    }
    
    /// <summary>
    /// The Endpoint status.
    /// </summary>
    public partial class DefinitionEndpointResponse
    {
        private string _domainName;
        
        /// <summary>
        /// Optional. The endpoint domain name.
        /// </summary>
        public string DomainName
        {
            get { return this._domainName; }
            set { this._domainName = value; }
        }
        
        private string _location;
        
        /// <summary>
        /// Optional. Specifies the location of an endpoint of type Any. This
        /// is required for Performance policies
        /// </summary>
        public string Location
        {
            get { return this._location; }
            set { this._location = value; }
        }
        
        private DefinitionEndpointMonitorStatus _monitorStatus;
        
        /// <summary>
        /// Optional. Indicates health status for the endpoint.
        /// </summary>
        public DefinitionEndpointMonitorStatus MonitorStatus
        {
            get { return this._monitorStatus; }
            set { this._monitorStatus = value; }
        }
        
        private EndpointStatus _status;
        
        /// <summary>
        /// Optional. The status of monitoring for the endpoint.
        /// </summary>
        public EndpointStatus Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        private EndpointType _type;
        
        /// <summary>
        /// Optional. Specifies the type of the endpoint.
        /// </summary>
        public EndpointType Type
        {
            get { return this._type; }
            set { this._type = value; }
        }
        
        private int _weight;
        
        /// <summary>
        /// Optional. Specifies the weight of an endpoint in a weighted round
        /// robin policy.
        /// </summary>
        public int Weight
        {
            get { return this._weight; }
            set { this._weight = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DefinitionEndpointResponse class.
        /// </summary>
        public DefinitionEndpointResponse()
        {
        }
    }
    
    /// <summary>
    /// The Get Definition operation response.
    /// </summary>
    public partial class DefinitionGetResponse : OperationResponse
    {
        private Definition _definition;
        
        /// <summary>
        /// Optional. Describes a definition for a specified profile.
        /// </summary>
        public Definition Definition
        {
            get { return this._definition; }
            set { this._definition = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DefinitionGetResponse class.
        /// </summary>
        public DefinitionGetResponse()
        {
        }
    }
    
    /// <summary>
    /// Describes a monitoring configuration
    /// </summary>
    public partial class DefinitionMonitor
    {
        private DefinitionMonitorHTTPOptions _httpOptions;
        
        /// <summary>
        /// Required. The option to use when making an HTTP request to monitor
        /// endpoint health.
        /// </summary>
        public DefinitionMonitorHTTPOptions HttpOptions
        {
            get { return this._httpOptions; }
            set { this._httpOptions = value; }
        }
        
        private int _intervalInSeconds;
        
        /// <summary>
        /// Required. The number of seconds between consecutive attempts to
        /// check the status of a monitoring endpoint. The value must be set
        /// to 30.
        /// </summary>
        public int IntervalInSeconds
        {
            get { return this._intervalInSeconds; }
            set { this._intervalInSeconds = value; }
        }
        
        private int _port;
        
        /// <summary>
        /// Required. The port used to monitor endpoint health. Accepted values
        /// are integer values greater than 0 and less or equal to 65,535.
        /// </summary>
        public int Port
        {
            get { return this._port; }
            set { this._port = value; }
        }
        
        private DefinitionMonitorProtocol _protocol;
        
        /// <summary>
        /// Required. The protocol to use to monitor endpoint health.
        /// </summary>
        public DefinitionMonitorProtocol Protocol
        {
            get { return this._protocol; }
            set { this._protocol = value; }
        }
        
        private int _timeoutInSeconds;
        
        /// <summary>
        /// Required. The time to wait for a response from the monitoring
        /// endpoint. The value must be set to 10.
        /// </summary>
        public int TimeoutInSeconds
        {
            get { return this._timeoutInSeconds; }
            set { this._timeoutInSeconds = value; }
        }
        
        private int _toleratedNumberOfFailures;
        
        /// <summary>
        /// Required. The number of consecutive failures to allow on an
        /// endpoint before taking the endpoint out of the rotation in the
        /// load balancer. The value must be set to 3.
        /// </summary>
        public int ToleratedNumberOfFailures
        {
            get { return this._toleratedNumberOfFailures; }
            set { this._toleratedNumberOfFailures = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DefinitionMonitor class.
        /// </summary>
        public DefinitionMonitor()
        {
        }
    }
    
    /// <summary>
    /// Describes the option to use when making an HTTP request to monitor
    /// endpoint health.
    /// </summary>
    public partial class DefinitionMonitorHTTPOptions
    {
        private int _expectedStatusCode;
        
        /// <summary>
        /// Optional. Specifies the HTTP status code expected from a healthy
        /// endpoint. Endpoint is considered unhealthy otherwise.
        /// </summary>
        public int ExpectedStatusCode
        {
            get { return this._expectedStatusCode; }
            set { this._expectedStatusCode = value; }
        }
        
        private string _relativePath;
        
        /// <summary>
        /// Optional. Specifies the path relative to the endpoint domain name
        /// to probe for health state. For restrictions, see
        /// http://msdn.microsoft.com/en-us/library/hh758254.aspx.
        /// </summary>
        public string RelativePath
        {
            get { return this._relativePath; }
            set { this._relativePath = value; }
        }
        
        private string _verb;
        
        /// <summary>
        /// Optional. Specifies the verb to use when making an HTTP request to
        /// monitor endpoint health.
        /// </summary>
        public string Verb
        {
            get { return this._verb; }
            set { this._verb = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DefinitionMonitorHTTPOptions
        /// class.
        /// </summary>
        public DefinitionMonitorHTTPOptions()
        {
        }
    }
    
    public enum DefinitionMonitorProtocol
    {
        Http = 0,
        
        Https = 1,
    }
    
    /// <summary>
    /// Specifies a monitoring policy.
    /// </summary>
    public partial class DefinitionPolicyCreateParameters
    {
        private IList<DefinitionEndpointCreateParameters> _endpoints;
        
        /// <summary>
        /// Required. Encapsulates the list of Windows Azure Traffic Manager
        /// endpoints. You can define up to 100 endpoints in the list. If the
        /// load balancing method is set to Failover, traffic to the endpoints
        /// is load balanced in the sequential order in which the endpoints
        /// are defined.
        /// </summary>
        public IList<DefinitionEndpointCreateParameters> Endpoints
        {
            get { return this._endpoints; }
            set { this._endpoints = value; }
        }
        
        private LoadBalancingMethod _loadBalancingMethod;
        
        /// <summary>
        /// Required. Specifies the load balancing method to use to distribute
        /// connections.
        /// </summary>
        public LoadBalancingMethod LoadBalancingMethod
        {
            get { return this._loadBalancingMethod; }
            set { this._loadBalancingMethod = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DefinitionPolicyCreateParameters
        /// class.
        /// </summary>
        public DefinitionPolicyCreateParameters()
        {
            this._endpoints = new List<DefinitionEndpointCreateParameters>();
        }
    }
    
    public enum DefinitionPolicyMonitorStatus
    {
        Online = 0,
        
        Degraded = 1,
        
        Inactive = 2,
        
        Disabled = 3,
        
        Stopped = 4,
        
        CheckingEndpoints = 5,
    }
    
    /// <summary>
    /// Describes the monitoring policy status
    /// </summary>
    public partial class DefinitionPolicyResponse : IEnumerable<DefinitionEndpointResponse>
    {
        private IList<DefinitionEndpointResponse> _endpoints;
        
        /// <summary>
        /// Optional. The list of Endpoints being monitored
        /// </summary>
        public IList<DefinitionEndpointResponse> Endpoints
        {
            get { return this._endpoints; }
            set { this._endpoints = value; }
        }
        
        private LoadBalancingMethod _loadBalancingMethod;
        
        /// <summary>
        /// Optional. Specifies the load balancing method to use to distribute
        /// connections.
        /// </summary>
        public LoadBalancingMethod LoadBalancingMethod
        {
            get { return this._loadBalancingMethod; }
            set { this._loadBalancingMethod = value; }
        }
        
        private DefinitionPolicyMonitorStatus _monitorStatus;
        
        /// <summary>
        /// Optional. Indicates health status for the overall load balancing
        /// policy.
        /// </summary>
        public DefinitionPolicyMonitorStatus MonitorStatus
        {
            get { return this._monitorStatus; }
            set { this._monitorStatus = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DefinitionPolicyResponse class.
        /// </summary>
        public DefinitionPolicyResponse()
        {
            this._endpoints = new List<DefinitionEndpointResponse>();
        }
        
        /// <summary>
        /// Gets the sequence of Endpoints.
        /// </summary>
        public IEnumerator<DefinitionEndpointResponse> GetEnumerator()
        {
            return this.Endpoints.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of Endpoints.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }
    
    /// <summary>
    /// The List Definitions operation response.
    /// </summary>
    public partial class DefinitionsListResponse : OperationResponse, IEnumerable<Definition>
    {
        private IList<Definition> _definitions;
        
        /// <summary>
        /// Optional. All definitions of a profile.
        /// </summary>
        public IList<Definition> Definitions
        {
            get { return this._definitions; }
            set { this._definitions = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DefinitionsListResponse class.
        /// </summary>
        public DefinitionsListResponse()
        {
            this._definitions = new List<Definition>();
        }
        
        /// <summary>
        /// Gets the sequence of Definitions.
        /// </summary>
        public IEnumerator<Definition> GetEnumerator()
        {
            return this.Definitions.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of Definitions.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }
    
    /// <summary>
    /// Describes the status and version of a definition.
    /// </summary>
    public partial class DefinitionStatusAndVersion
    {
        private ProfileDefinitionStatus _status;
        
        /// <summary>
        /// Optional. Indicates whether a definition of the specified profile
        /// is enabled or disabled in Windows Azure Traffic Manager.
        /// </summary>
        public ProfileDefinitionStatus Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        private int _version;
        
        /// <summary>
        /// Optional. The version of the policy definition. This value is
        /// always 1.
        /// </summary>
        public int Version
        {
            get { return this._version; }
            set { this._version = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DefinitionStatusAndVersion class.
        /// </summary>
        public DefinitionStatusAndVersion()
        {
        }
    }
    
    /// <summary>
    /// The response to the request for a listing of namespaces.
    /// </summary>
    public partial class DnsPrefixAvailabilityCheckResponse : OperationResponse
    {
        private bool _result;
        
        /// <summary>
        /// Optional. The DNS name is available for you to use.
        /// </summary>
        public bool Result
        {
            get { return this._result; }
            set { this._result = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// DnsPrefixAvailabilityCheckResponse class.
        /// </summary>
        public DnsPrefixAvailabilityCheckResponse()
        {
        }
    }
    
    public enum EndpointStatus
    {
        Enabled = 0,
        
        Disabled = 1,
    }
    
    public enum EndpointType
    {
        /// <summary>
        /// The type of Azure Cloud Services from the current subscription.
        /// </summary>
        CloudService = 0,
        
        /// <summary>
        /// The type of Azure Websites from the current subscription.
        /// </summary>
        AzureWebsite = 1,
        
        /// <summary>
        /// The type of endpoints that can have any domain name (not
        /// necessarily an Azure domain). Note that Azure Websites cannot be
        /// entered as endpoints of type "Any".
        /// </summary>
        Any = 2,
    }
    
    public enum LoadBalancingMethod
    {
        Performance = 0,
        
        Failover = 1,
        
        RoundRobin = 2,
    }
    
    /// <summary>
    /// Describes a profile.
    /// </summary>
    public partial class Profile
    {
        private IList<DefinitionStatusAndVersion> _definitions;
        
        /// <summary>
        /// Optional. Specifies the definition for the specified profile, along
        /// with the status. Only one definition version exists for a profile.
        /// </summary>
        public IList<DefinitionStatusAndVersion> Definitions
        {
            get { return this._definitions; }
            set { this._definitions = value; }
        }
        
        private string _domainName;
        
        /// <summary>
        /// Optional. The domain name, as specified during the creation of the
        /// profile.
        /// </summary>
        public string DomainName
        {
            get { return this._domainName; }
            set { this._domainName = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// Optional. The profile name, as specified during the creation of the
        /// profile.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private ProfileDefinitionStatus _status;
        
        /// <summary>
        /// Optional. Indicates whether a definition of the specified profile
        /// is enabled or disabled in Windows Azure Traffic Manager.
        /// </summary>
        public ProfileDefinitionStatus Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        private ProfileStatusDetails _statusDetails;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public ProfileStatusDetails StatusDetails
        {
            get { return this._statusDetails; }
            set { this._statusDetails = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the Profile class.
        /// </summary>
        public Profile()
        {
            this._definitions = new List<DefinitionStatusAndVersion>();
        }
    }
    
    public enum ProfileDefinitionStatus
    {
        Enabled = 0,
        
        Disabled = 1,
    }
    
    /// <summary>
    /// The Get Profile Details operation response.
    /// </summary>
    public partial class ProfileGetResponse : OperationResponse
    {
        private Profile _profile;
        
        /// <summary>
        /// Optional. Details for the requested profile.
        /// </summary>
        public Profile Profile
        {
            get { return this._profile; }
            set { this._profile = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ProfileGetResponse class.
        /// </summary>
        public ProfileGetResponse()
        {
        }
    }
    
    /// <summary>
    /// The List Profiles operation response.
    /// </summary>
    public partial class ProfilesListResponse : OperationResponse, IEnumerable<Profile>
    {
        private IList<Profile> _profiles;
        
        /// <summary>
        /// Optional. The profiles associated with the specified subscription.
        /// </summary>
        public IList<Profile> Profiles
        {
            get { return this._profiles; }
            set { this._profiles = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ProfilesListResponse class.
        /// </summary>
        public ProfilesListResponse()
        {
            this._profiles = new List<Profile>();
        }
        
        /// <summary>
        /// Gets the sequence of Profiles.
        /// </summary>
        public IEnumerator<Profile> GetEnumerator()
        {
            return this.Profiles.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of Profiles.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }
    
    /// <summary>
    /// The detail status of the profile
    /// </summary>
    public partial class ProfileStatusDetails
    {
        private int _enabledDefinitionVersion;
        
        /// <summary>
        /// Optional. Specifies the version of the policy definition. This
        /// value is always 1.
        /// </summary>
        public int EnabledDefinitionVersion
        {
            get { return this._enabledDefinitionVersion; }
            set { this._enabledDefinitionVersion = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ProfileStatusDetails class.
        /// </summary>
        public ProfileStatusDetails()
        {
        }
    }
}

namespace Microsoft.WindowsAzure.Management.TrafficManager
{
    /// <summary>
    /// The Windows Azure Traffic Manager management API provides a RESTful set
    /// of web services that interact with Windows Azure Traffic Manager
    /// service for creating, updating, listing, and deleting Traffic Manager
    /// profiles and definitions.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/dn166981.aspx for
    /// more information)
    /// </summary>
    public partial interface ITrafficManagerClient : IDisposable
    {
        /// <summary>
        /// The URI used as the base for all Service Management requests.
        /// </summary>
        Uri BaseUri
        {
            get; 
        }
        
        /// <summary>
        /// When you create a Windows Azure subscription, it is uniquely
        /// identified by a subscription ID. The subscription ID forms part of
        /// the URI for every call that you make to the Service Management
        /// API.  The Windows Azure Service ManagementAPI use mutual
        /// authentication of management certificates over SSL to ensure that
        /// a request made to the service is secure.  No anonymous requests
        /// are allowed.
        /// </summary>
        SubscriptionCloudCredentials Credentials
        {
            get; 
        }
        
        /// <summary>
        /// The Traffic Manager API includes operations for managing
        /// definitions for a specified profile.
        /// </summary>
        IDefinitionOperations Definitions
        {
            get; 
        }
        
        /// <summary>
        /// The Traffic Manager API includes operations for managing Traffic
        /// Manager profiles.
        /// </summary>
        IProfileOperations Profiles
        {
            get; 
        }
    }
    
    /// <summary>
    /// The Windows Azure Traffic Manager management API provides a RESTful set
    /// of web services that interact with Windows Azure Traffic Manager
    /// service for creating, updating, listing, and deleting Traffic Manager
    /// profiles and definitions.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/dn166981.aspx for
    /// more information)
    /// </summary>
    public partial class TrafficManagerClient : ServiceClient<TrafficManagerClient>, ITrafficManagerClient
    {
        private Uri _baseUri;
        
        /// <summary>
        /// The URI used as the base for all Service Management requests.
        /// </summary>
        public Uri BaseUri
        {
            get { return this._baseUri; }
        }
        
        private SubscriptionCloudCredentials _credentials;
        
        /// <summary>
        /// When you create a Windows Azure subscription, it is uniquely
        /// identified by a subscription ID. The subscription ID forms part of
        /// the URI for every call that you make to the Service Management
        /// API.  The Windows Azure Service ManagementAPI use mutual
        /// authentication of management certificates over SSL to ensure that
        /// a request made to the service is secure.  No anonymous requests
        /// are allowed.
        /// </summary>
        public SubscriptionCloudCredentials Credentials
        {
            get { return this._credentials; }
        }
        
        private IDefinitionOperations _definitions;
        
        /// <summary>
        /// The Traffic Manager API includes operations for managing
        /// definitions for a specified profile.
        /// </summary>
        public virtual IDefinitionOperations Definitions
        {
            get { return this._definitions; }
        }
        
        private IProfileOperations _profiles;
        
        /// <summary>
        /// The Traffic Manager API includes operations for managing Traffic
        /// Manager profiles.
        /// </summary>
        public virtual IProfileOperations Profiles
        {
            get { return this._profiles; }
        }
        
        /// <summary>
        /// Initializes a new instance of the TrafficManagerClient class.
        /// </summary>
        private TrafficManagerClient()
            : base()
        {
            this._definitions = new DefinitionOperations(this);
            this._profiles = new ProfileOperations(this);
            this.HttpClient.Timeout = TimeSpan.FromSeconds(300);
        }
        
        /// <summary>
        /// Initializes a new instance of the TrafficManagerClient class.
        /// </summary>
        /// <param name='credentials'>
        /// Required. When you create a Windows Azure subscription, it is
        /// uniquely identified by a subscription ID. The subscription ID
        /// forms part of the URI for every call that you make to the Service
        /// Management API.  The Windows Azure Service ManagementAPI use
        /// mutual authentication of management certificates over SSL to
        /// ensure that a request made to the service is secure.  No anonymous
        /// requests are allowed.
        /// </param>
        /// <param name='baseUri'>
        /// Required. The URI used as the base for all Service Management
        /// requests.
        /// </param>
        public TrafficManagerClient(SubscriptionCloudCredentials credentials, Uri baseUri)
            : this()
        {
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            this._credentials = credentials;
            this._baseUri = baseUri;
            
            this.Credentials.InitializeServiceClient(this);
        }
        
        /// <summary>
        /// Initializes a new instance of the TrafficManagerClient class.
        /// </summary>
        /// <param name='credentials'>
        /// Required. When you create a Windows Azure subscription, it is
        /// uniquely identified by a subscription ID. The subscription ID
        /// forms part of the URI for every call that you make to the Service
        /// Management API.  The Windows Azure Service ManagementAPI use
        /// mutual authentication of management certificates over SSL to
        /// ensure that a request made to the service is secure.  No anonymous
        /// requests are allowed.
        /// </param>
        public TrafficManagerClient(SubscriptionCloudCredentials credentials)
            : this()
        {
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this._credentials = credentials;
            this._baseUri = new Uri("https://management.core.windows.net");
            
            this.Credentials.InitializeServiceClient(this);
        }
        
        /// <summary>
        /// Parse enum values for type DefinitionMonitorProtocol.
        /// </summary>
        /// <param name='value'>
        /// The value to parse.
        /// </param>
        /// <returns>
        /// The enum value.
        /// </returns>
        internal static DefinitionMonitorProtocol ParseDefinitionMonitorProtocol(string value)
        {
            if ("HTTP".Equals(value, StringComparison.OrdinalIgnoreCase))
            {
                return DefinitionMonitorProtocol.Http;
            }
            if ("HTTPS".Equals(value, StringComparison.OrdinalIgnoreCase))
            {
                return DefinitionMonitorProtocol.Https;
            }
            throw new ArgumentOutOfRangeException("value");
        }
        
        /// <summary>
        /// Convert an enum of type DefinitionMonitorProtocol to a string.
        /// </summary>
        /// <param name='value'>
        /// The value to convert to a string.
        /// </param>
        /// <returns>
        /// The enum value as a string.
        /// </returns>
        internal static string DefinitionMonitorProtocolToString(DefinitionMonitorProtocol value)
        {
            if (value == DefinitionMonitorProtocol.Http)
            {
                return "HTTP";
            }
            if (value == DefinitionMonitorProtocol.Https)
            {
                return "HTTPS";
            }
            throw new ArgumentOutOfRangeException("value");
        }
    }
    
    /// <summary>
    /// The Traffic Manager API includes operations for managing definitions
    /// for a specified profile.
    /// </summary>
    public partial interface IDefinitionOperations
    {
        /// <summary>
        /// Creates a new definition for a specified profile.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758257.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// The name of the profile to create a new definition for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Definition operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> CreateAsync(string profileName, DefinitionCreateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// Returns an existing profile definition.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758248.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// The name of the profile to get definition from.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Definition operation response.
        /// </returns>
        Task<DefinitionGetResponse> GetAsync(string profileName, CancellationToken cancellationToken);
        
        /// <summary>
        /// Returns all definitions of a profile  (see
        /// http://msdn.microsoft.com/en-us/library/hh758252.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// The name of the profile to return all definitions
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Definitions operation response.
        /// </returns>
        Task<DefinitionsListResponse> ListAsync(string profileName, CancellationToken cancellationToken);
    }
    
    /// <summary>
    /// The Traffic Manager API includes operations for managing definitions
    /// for a specified profile.
    /// </summary>
    internal partial class DefinitionOperations : IServiceOperations<TrafficManagerClient>, IDefinitionOperations
    {
        /// <summary>
        /// Initializes a new instance of the DefinitionOperations class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        internal DefinitionOperations(TrafficManagerClient client)
        {
            this._client = client;
        }
        
        private TrafficManagerClient _client;
        
        /// <summary>
        /// Gets a reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.TrafficManagerClient.
        /// </summary>
        public TrafficManagerClient Client
        {
            get { return this._client; }
        }
        
        /// <summary>
        /// Creates a new definition for a specified profile.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758257.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// Required. The name of the profile to create a new definition for.
        /// </param>
        /// <param name='parameters'>
        /// Required. Parameters supplied to the Create Definition operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> CreateAsync(string profileName, DefinitionCreateParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (profileName == null)
            {
                throw new ArgumentNullException("profileName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.DnsOptions == null)
            {
                throw new ArgumentNullException("parameters.DnsOptions");
            }
            if (parameters.Monitors == null)
            {
                throw new ArgumentNullException("parameters.Monitors");
            }
            if (parameters.Monitors != null)
            {
                foreach (DefinitionMonitor monitorsParameterItem in parameters.Monitors)
                {
                    if (monitorsParameterItem.HttpOptions == null)
                    {
                        throw new ArgumentNullException("parameters.Monitors.HttpOptions");
                    }
                }
            }
            if (parameters.Policy == null)
            {
                throw new ArgumentNullException("parameters.Policy");
            }
            if (parameters.Policy.Endpoints == null)
            {
                throw new ArgumentNullException("parameters.Policy.Endpoints");
            }
            if (parameters.Policy.Endpoints != null)
            {
                foreach (DefinitionEndpointCreateParameters endpointsParameterItem in parameters.Policy.Endpoints)
                {
                    if (endpointsParameterItem.DomainName == null)
                    {
                        throw new ArgumentNullException("parameters.Policy.Endpoints.DomainName");
                    }
                }
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("profileName", profileName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "CreateAsync", tracingParameters);
            }
            
            // Construct URL
            string baseUrl = this.Client.BaseUri.AbsoluteUri;
            string url = "/" + (this.Client.Credentials.SubscriptionId != null ? this.Client.Credentials.SubscriptionId.Trim() : "") + "/services/WATM/profiles/" + profileName.Trim() + "/definitions";
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2011-10-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement definitionElement = new XElement(XName.Get("Definition", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(definitionElement);
                
                XElement dnsOptionsElement = new XElement(XName.Get("DnsOptions", "http://schemas.microsoft.com/windowsazure"));
                definitionElement.Add(dnsOptionsElement);
                
                XElement timeToLiveInSecondsElement = new XElement(XName.Get("TimeToLiveInSeconds", "http://schemas.microsoft.com/windowsazure"));
                timeToLiveInSecondsElement.Value = parameters.DnsOptions.TimeToLiveInSeconds.ToString();
                dnsOptionsElement.Add(timeToLiveInSecondsElement);
                
                XElement monitorsSequenceElement = new XElement(XName.Get("Monitors", "http://schemas.microsoft.com/windowsazure"));
                foreach (DefinitionMonitor monitorsItem in parameters.Monitors)
                {
                    XElement monitorElement = new XElement(XName.Get("Monitor", "http://schemas.microsoft.com/windowsazure"));
                    monitorsSequenceElement.Add(monitorElement);
                    
                    XElement intervalInSecondsElement = new XElement(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                    intervalInSecondsElement.Value = monitorsItem.IntervalInSeconds.ToString();
                    monitorElement.Add(intervalInSecondsElement);
                    
                    XElement timeoutInSecondsElement = new XElement(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                    timeoutInSecondsElement.Value = monitorsItem.TimeoutInSeconds.ToString();
                    monitorElement.Add(timeoutInSecondsElement);
                    
                    XElement toleratedNumberOfFailuresElement = new XElement(XName.Get("ToleratedNumberOfFailures", "http://schemas.microsoft.com/windowsazure"));
                    toleratedNumberOfFailuresElement.Value = monitorsItem.ToleratedNumberOfFailures.ToString();
                    monitorElement.Add(toleratedNumberOfFailuresElement);
                    
                    XElement protocolElement = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                    protocolElement.Value = TrafficManagerClient.DefinitionMonitorProtocolToString(monitorsItem.Protocol);
                    monitorElement.Add(protocolElement);
                    
                    XElement portElement = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                    portElement.Value = monitorsItem.Port.ToString();
                    monitorElement.Add(portElement);
                    
                    XElement httpOptionsElement = new XElement(XName.Get("HttpOptions", "http://schemas.microsoft.com/windowsazure"));
                    monitorElement.Add(httpOptionsElement);
                    
                    if (monitorsItem.HttpOptions.Verb != null)
                    {
                        XElement verbElement = new XElement(XName.Get("Verb", "http://schemas.microsoft.com/windowsazure"));
                        verbElement.Value = "GET";
                        httpOptionsElement.Add(verbElement);
                    }
                    
                    if (monitorsItem.HttpOptions.RelativePath != null)
                    {
                        XElement relativePathElement = new XElement(XName.Get("RelativePath", "http://schemas.microsoft.com/windowsazure"));
                        relativePathElement.Value = monitorsItem.HttpOptions.RelativePath;
                        httpOptionsElement.Add(relativePathElement);
                    }
                    
                    XElement expectedStatusCodeElement = new XElement(XName.Get("ExpectedStatusCode", "http://schemas.microsoft.com/windowsazure"));
                    expectedStatusCodeElement.Value = "200";
                    httpOptionsElement.Add(expectedStatusCodeElement);
                }
                definitionElement.Add(monitorsSequenceElement);
                
                XElement policyElement = new XElement(XName.Get("Policy", "http://schemas.microsoft.com/windowsazure"));
                definitionElement.Add(policyElement);
                
                XElement loadBalancingMethodElement = new XElement(XName.Get("LoadBalancingMethod", "http://schemas.microsoft.com/windowsazure"));
                loadBalancingMethodElement.Value = parameters.Policy.LoadBalancingMethod.ToString();
                policyElement.Add(loadBalancingMethodElement);
                
                XElement endpointsSequenceElement = new XElement(XName.Get("Endpoints", "http://schemas.microsoft.com/windowsazure"));
                foreach (DefinitionEndpointCreateParameters endpointsItem in parameters.Policy.Endpoints)
                {
                    XElement endpointElement = new XElement(XName.Get("Endpoint", "http://schemas.microsoft.com/windowsazure"));
                    endpointsSequenceElement.Add(endpointElement);
                    
                    XElement domainNameElement = new XElement(XName.Get("DomainName", "http://schemas.microsoft.com/windowsazure"));
                    domainNameElement.Value = endpointsItem.DomainName;
                    endpointElement.Add(domainNameElement);
                    
                    XElement statusElement = new XElement(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                    statusElement.Value = endpointsItem.Status.ToString();
                    endpointElement.Add(statusElement);
                    
                    XElement typeElement = new XElement(XName.Get("Type", "http://schemas.microsoft.com/windowsazure"));
                    typeElement.Value = endpointsItem.Type.ToString();
                    endpointElement.Add(typeElement);
                    
                    XElement weightElement = new XElement(XName.Get("Weight", "http://schemas.microsoft.com/windowsazure"));
                    weightElement.Value = endpointsItem.Weight.ToString();
                    endpointElement.Add(weightElement);
                    
                    if (endpointsItem.Location != null)
                    {
                        XElement locationElement = new XElement(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                        locationElement.Value = endpointsItem.Location;
                        endpointElement.Add(locationElement);
                    }
                }
                policyElement.Add(endpointsSequenceElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.Create(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false), CloudExceptionType.Xml);
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = null;
                    result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Returns an existing profile definition.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758248.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// Required. The name of the profile to get definition from.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Definition operation response.
        /// </returns>
        public async Task<DefinitionGetResponse> GetAsync(string profileName, CancellationToken cancellationToken)
        {
            // Validate
            if (profileName == null)
            {
                throw new ArgumentNullException("profileName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("profileName", profileName);
                Tracing.Enter(invocationId, this, "GetAsync", tracingParameters);
            }
            
            // Construct URL
            string baseUrl = this.Client.BaseUri.AbsoluteUri;
            string url = "/" + (this.Client.Credentials.SubscriptionId != null ? this.Client.Credentials.SubscriptionId.Trim() : "") + "/services/WATM/profiles/" + profileName.Trim() + "/definitions/1";
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2011-10-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.Create(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false), CloudExceptionType.Xml);
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    DefinitionGetResponse result = null;
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    result = new DefinitionGetResponse();
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement definitionElement = responseDoc.Element(XName.Get("Definition", "http://schemas.microsoft.com/windowsazure"));
                    if (definitionElement != null)
                    {
                        Definition definitionInstance = new Definition();
                        result.Definition = definitionInstance;
                        
                        XElement dnsOptionsElement = definitionElement.Element(XName.Get("DnsOptions", "http://schemas.microsoft.com/windowsazure"));
                        if (dnsOptionsElement != null)
                        {
                            DefinitionDnsOptions dnsOptionsInstance = new DefinitionDnsOptions();
                            definitionInstance.DnsOptions = dnsOptionsInstance;
                            
                            XElement timeToLiveInSecondsElement = dnsOptionsElement.Element(XName.Get("TimeToLiveInSeconds", "http://schemas.microsoft.com/windowsazure"));
                            if (timeToLiveInSecondsElement != null)
                            {
                                int timeToLiveInSecondsInstance = int.Parse(timeToLiveInSecondsElement.Value, CultureInfo.InvariantCulture);
                                dnsOptionsInstance.TimeToLiveInSeconds = timeToLiveInSecondsInstance;
                            }
                        }
                        
                        XElement statusElement = definitionElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                        if (statusElement != null)
                        {
                            ProfileDefinitionStatus statusInstance = ((ProfileDefinitionStatus)Enum.Parse(typeof(ProfileDefinitionStatus), statusElement.Value, true));
                            definitionInstance.Status = statusInstance;
                        }
                        
                        XElement versionElement = definitionElement.Element(XName.Get("Version", "http://schemas.microsoft.com/windowsazure"));
                        if (versionElement != null)
                        {
                            int versionInstance = int.Parse(versionElement.Value, CultureInfo.InvariantCulture);
                            definitionInstance.Version = versionInstance;
                        }
                        
                        XElement monitorsSequenceElement = definitionElement.Element(XName.Get("Monitors", "http://schemas.microsoft.com/windowsazure"));
                        if (monitorsSequenceElement != null)
                        {
                            foreach (XElement monitorsElement in monitorsSequenceElement.Elements(XName.Get("Monitor", "http://schemas.microsoft.com/windowsazure")))
                            {
                                DefinitionMonitor monitorInstance = new DefinitionMonitor();
                                definitionInstance.Monitors.Add(monitorInstance);
                                
                                XElement intervalInSecondsElement = monitorsElement.Element(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                if (intervalInSecondsElement != null)
                                {
                                    int intervalInSecondsInstance = int.Parse(intervalInSecondsElement.Value, CultureInfo.InvariantCulture);
                                    monitorInstance.IntervalInSeconds = intervalInSecondsInstance;
                                }
                                
                                XElement timeoutInSecondsElement = monitorsElement.Element(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                if (timeoutInSecondsElement != null)
                                {
                                    int timeoutInSecondsInstance = int.Parse(timeoutInSecondsElement.Value, CultureInfo.InvariantCulture);
                                    monitorInstance.TimeoutInSeconds = timeoutInSecondsInstance;
                                }
                                
                                XElement toleratedNumberOfFailuresElement = monitorsElement.Element(XName.Get("ToleratedNumberOfFailures", "http://schemas.microsoft.com/windowsazure"));
                                if (toleratedNumberOfFailuresElement != null)
                                {
                                    int toleratedNumberOfFailuresInstance = int.Parse(toleratedNumberOfFailuresElement.Value, CultureInfo.InvariantCulture);
                                    monitorInstance.ToleratedNumberOfFailures = toleratedNumberOfFailuresInstance;
                                }
                                
                                XElement protocolElement = monitorsElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                if (protocolElement != null)
                                {
                                    DefinitionMonitorProtocol protocolInstance = TrafficManagerClient.ParseDefinitionMonitorProtocol(protocolElement.Value);
                                    monitorInstance.Protocol = protocolInstance;
                                }
                                
                                XElement portElement = monitorsElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                if (portElement != null)
                                {
                                    int portInstance = int.Parse(portElement.Value, CultureInfo.InvariantCulture);
                                    monitorInstance.Port = portInstance;
                                }
                                
                                XElement httpOptionsElement = monitorsElement.Element(XName.Get("HttpOptions", "http://schemas.microsoft.com/windowsazure"));
                                if (httpOptionsElement != null)
                                {
                                    DefinitionMonitorHTTPOptions httpOptionsInstance = new DefinitionMonitorHTTPOptions();
                                    monitorInstance.HttpOptions = httpOptionsInstance;
                                    
                                    XElement verbElement = httpOptionsElement.Element(XName.Get("Verb", "http://schemas.microsoft.com/windowsazure"));
                                    if (verbElement != null)
                                    {
                                        string verbInstance = verbElement.Value;
                                        httpOptionsInstance.Verb = verbInstance;
                                    }
                                    
                                    XElement relativePathElement = httpOptionsElement.Element(XName.Get("RelativePath", "http://schemas.microsoft.com/windowsazure"));
                                    if (relativePathElement != null)
                                    {
                                        string relativePathInstance = relativePathElement.Value;
                                        httpOptionsInstance.RelativePath = relativePathInstance;
                                    }
                                    
                                    XElement expectedStatusCodeElement = httpOptionsElement.Element(XName.Get("ExpectedStatusCode", "http://schemas.microsoft.com/windowsazure"));
                                    if (expectedStatusCodeElement != null)
                                    {
                                        int expectedStatusCodeInstance = int.Parse(expectedStatusCodeElement.Value, CultureInfo.InvariantCulture);
                                        httpOptionsInstance.ExpectedStatusCode = expectedStatusCodeInstance;
                                    }
                                }
                            }
                        }
                        
                        XElement policyElement = definitionElement.Element(XName.Get("Policy", "http://schemas.microsoft.com/windowsazure"));
                        if (policyElement != null)
                        {
                            DefinitionPolicyResponse policyInstance = new DefinitionPolicyResponse();
                            definitionInstance.Policy = policyInstance;
                            
                            XElement loadBalancingMethodElement = policyElement.Element(XName.Get("LoadBalancingMethod", "http://schemas.microsoft.com/windowsazure"));
                            if (loadBalancingMethodElement != null)
                            {
                                LoadBalancingMethod loadBalancingMethodInstance = ((LoadBalancingMethod)Enum.Parse(typeof(LoadBalancingMethod), loadBalancingMethodElement.Value, true));
                                policyInstance.LoadBalancingMethod = loadBalancingMethodInstance;
                            }
                            
                            XElement endpointsSequenceElement = policyElement.Element(XName.Get("Endpoints", "http://schemas.microsoft.com/windowsazure"));
                            if (endpointsSequenceElement != null)
                            {
                                foreach (XElement endpointsElement in endpointsSequenceElement.Elements(XName.Get("Endpoint", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    DefinitionEndpointResponse endpointInstance = new DefinitionEndpointResponse();
                                    policyInstance.Endpoints.Add(endpointInstance);
                                    
                                    XElement domainNameElement = endpointsElement.Element(XName.Get("DomainName", "http://schemas.microsoft.com/windowsazure"));
                                    if (domainNameElement != null)
                                    {
                                        string domainNameInstance = domainNameElement.Value;
                                        endpointInstance.DomainName = domainNameInstance;
                                    }
                                    
                                    XElement statusElement2 = endpointsElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                                    if (statusElement2 != null)
                                    {
                                        EndpointStatus statusInstance2 = ((EndpointStatus)Enum.Parse(typeof(EndpointStatus), statusElement2.Value, true));
                                        endpointInstance.Status = statusInstance2;
                                    }
                                    
                                    XElement typeElement = endpointsElement.Element(XName.Get("Type", "http://schemas.microsoft.com/windowsazure"));
                                    if (typeElement != null)
                                    {
                                        EndpointType typeInstance = ((EndpointType)Enum.Parse(typeof(EndpointType), typeElement.Value, true));
                                        endpointInstance.Type = typeInstance;
                                    }
                                    
                                    XElement locationElement = endpointsElement.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                                    if (locationElement != null)
                                    {
                                        string locationInstance = locationElement.Value;
                                        endpointInstance.Location = locationInstance;
                                    }
                                    
                                    XElement monitorStatusElement = endpointsElement.Element(XName.Get("MonitorStatus", "http://schemas.microsoft.com/windowsazure"));
                                    if (monitorStatusElement != null)
                                    {
                                        DefinitionEndpointMonitorStatus monitorStatusInstance = ((DefinitionEndpointMonitorStatus)Enum.Parse(typeof(DefinitionEndpointMonitorStatus), monitorStatusElement.Value, true));
                                        endpointInstance.MonitorStatus = monitorStatusInstance;
                                    }
                                    
                                    XElement weightElement = endpointsElement.Element(XName.Get("Weight", "http://schemas.microsoft.com/windowsazure"));
                                    if (weightElement != null)
                                    {
                                        int weightInstance = int.Parse(weightElement.Value, CultureInfo.InvariantCulture);
                                        endpointInstance.Weight = weightInstance;
                                    }
                                }
                            }
                            
                            XElement monitorStatusElement2 = policyElement.Element(XName.Get("MonitorStatus", "http://schemas.microsoft.com/windowsazure"));
                            if (monitorStatusElement2 != null)
                            {
                                DefinitionPolicyMonitorStatus monitorStatusInstance2 = ((DefinitionPolicyMonitorStatus)Enum.Parse(typeof(DefinitionPolicyMonitorStatus), monitorStatusElement2.Value, true));
                                policyInstance.MonitorStatus = monitorStatusInstance2;
                            }
                        }
                    }
                    
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Returns all definitions of a profile  (see
        /// http://msdn.microsoft.com/en-us/library/hh758252.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// Required. The name of the profile to return all definitions
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Definitions operation response.
        /// </returns>
        public async Task<DefinitionsListResponse> ListAsync(string profileName, CancellationToken cancellationToken)
        {
            // Validate
            if (profileName == null)
            {
                throw new ArgumentNullException("profileName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("profileName", profileName);
                Tracing.Enter(invocationId, this, "ListAsync", tracingParameters);
            }
            
            // Construct URL
            string baseUrl = this.Client.BaseUri.AbsoluteUri;
            string url = "/" + (this.Client.Credentials.SubscriptionId != null ? this.Client.Credentials.SubscriptionId.Trim() : "") + "/services/WATM/profiles/" + profileName.Trim() + "/definitions";
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2011-10-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.Create(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false), CloudExceptionType.Xml);
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    DefinitionsListResponse result = null;
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    result = new DefinitionsListResponse();
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement definitionsSequenceElement = responseDoc.Element(XName.Get("Definitions", "http://schemas.microsoft.com/windowsazure"));
                    if (definitionsSequenceElement != null)
                    {
                        foreach (XElement definitionsElement in definitionsSequenceElement.Elements(XName.Get("Definition", "http://schemas.microsoft.com/windowsazure")))
                        {
                            Definition definitionInstance = new Definition();
                            result.Definitions.Add(definitionInstance);
                            
                            XElement dnsOptionsElement = definitionsElement.Element(XName.Get("DnsOptions", "http://schemas.microsoft.com/windowsazure"));
                            if (dnsOptionsElement != null)
                            {
                                DefinitionDnsOptions dnsOptionsInstance = new DefinitionDnsOptions();
                                definitionInstance.DnsOptions = dnsOptionsInstance;
                                
                                XElement timeToLiveInSecondsElement = dnsOptionsElement.Element(XName.Get("TimeToLiveInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                if (timeToLiveInSecondsElement != null)
                                {
                                    int timeToLiveInSecondsInstance = int.Parse(timeToLiveInSecondsElement.Value, CultureInfo.InvariantCulture);
                                    dnsOptionsInstance.TimeToLiveInSeconds = timeToLiveInSecondsInstance;
                                }
                            }
                            
                            XElement statusElement = definitionsElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                            if (statusElement != null)
                            {
                                ProfileDefinitionStatus statusInstance = ((ProfileDefinitionStatus)Enum.Parse(typeof(ProfileDefinitionStatus), statusElement.Value, true));
                                definitionInstance.Status = statusInstance;
                            }
                            
                            XElement versionElement = definitionsElement.Element(XName.Get("Version", "http://schemas.microsoft.com/windowsazure"));
                            if (versionElement != null)
                            {
                                int versionInstance = int.Parse(versionElement.Value, CultureInfo.InvariantCulture);
                                definitionInstance.Version = versionInstance;
                            }
                            
                            XElement monitorsSequenceElement = definitionsElement.Element(XName.Get("Monitors", "http://schemas.microsoft.com/windowsazure"));
                            if (monitorsSequenceElement != null)
                            {
                                foreach (XElement monitorsElement in monitorsSequenceElement.Elements(XName.Get("Monitor", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    DefinitionMonitor monitorInstance = new DefinitionMonitor();
                                    definitionInstance.Monitors.Add(monitorInstance);
                                    
                                    XElement intervalInSecondsElement = monitorsElement.Element(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                    if (intervalInSecondsElement != null)
                                    {
                                        int intervalInSecondsInstance = int.Parse(intervalInSecondsElement.Value, CultureInfo.InvariantCulture);
                                        monitorInstance.IntervalInSeconds = intervalInSecondsInstance;
                                    }
                                    
                                    XElement timeoutInSecondsElement = monitorsElement.Element(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                    if (timeoutInSecondsElement != null)
                                    {
                                        int timeoutInSecondsInstance = int.Parse(timeoutInSecondsElement.Value, CultureInfo.InvariantCulture);
                                        monitorInstance.TimeoutInSeconds = timeoutInSecondsInstance;
                                    }
                                    
                                    XElement toleratedNumberOfFailuresElement = monitorsElement.Element(XName.Get("ToleratedNumberOfFailures", "http://schemas.microsoft.com/windowsazure"));
                                    if (toleratedNumberOfFailuresElement != null)
                                    {
                                        int toleratedNumberOfFailuresInstance = int.Parse(toleratedNumberOfFailuresElement.Value, CultureInfo.InvariantCulture);
                                        monitorInstance.ToleratedNumberOfFailures = toleratedNumberOfFailuresInstance;
                                    }
                                    
                                    XElement protocolElement = monitorsElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                    if (protocolElement != null)
                                    {
                                        DefinitionMonitorProtocol protocolInstance = TrafficManagerClient.ParseDefinitionMonitorProtocol(protocolElement.Value);
                                        monitorInstance.Protocol = protocolInstance;
                                    }
                                    
                                    XElement portElement = monitorsElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                    if (portElement != null)
                                    {
                                        int portInstance = int.Parse(portElement.Value, CultureInfo.InvariantCulture);
                                        monitorInstance.Port = portInstance;
                                    }
                                    
                                    XElement httpOptionsElement = monitorsElement.Element(XName.Get("HttpOptions", "http://schemas.microsoft.com/windowsazure"));
                                    if (httpOptionsElement != null)
                                    {
                                        DefinitionMonitorHTTPOptions httpOptionsInstance = new DefinitionMonitorHTTPOptions();
                                        monitorInstance.HttpOptions = httpOptionsInstance;
                                        
                                        XElement verbElement = httpOptionsElement.Element(XName.Get("Verb", "http://schemas.microsoft.com/windowsazure"));
                                        if (verbElement != null)
                                        {
                                            string verbInstance = verbElement.Value;
                                            httpOptionsInstance.Verb = verbInstance;
                                        }
                                        
                                        XElement relativePathElement = httpOptionsElement.Element(XName.Get("RelativePath", "http://schemas.microsoft.com/windowsazure"));
                                        if (relativePathElement != null)
                                        {
                                            string relativePathInstance = relativePathElement.Value;
                                            httpOptionsInstance.RelativePath = relativePathInstance;
                                        }
                                        
                                        XElement expectedStatusCodeElement = httpOptionsElement.Element(XName.Get("ExpectedStatusCode", "http://schemas.microsoft.com/windowsazure"));
                                        if (expectedStatusCodeElement != null)
                                        {
                                            int expectedStatusCodeInstance = int.Parse(expectedStatusCodeElement.Value, CultureInfo.InvariantCulture);
                                            httpOptionsInstance.ExpectedStatusCode = expectedStatusCodeInstance;
                                        }
                                    }
                                }
                            }
                            
                            XElement policyElement = definitionsElement.Element(XName.Get("Policy", "http://schemas.microsoft.com/windowsazure"));
                            if (policyElement != null)
                            {
                                DefinitionPolicyResponse policyInstance = new DefinitionPolicyResponse();
                                definitionInstance.Policy = policyInstance;
                                
                                XElement loadBalancingMethodElement = policyElement.Element(XName.Get("LoadBalancingMethod", "http://schemas.microsoft.com/windowsazure"));
                                if (loadBalancingMethodElement != null)
                                {
                                    LoadBalancingMethod loadBalancingMethodInstance = ((LoadBalancingMethod)Enum.Parse(typeof(LoadBalancingMethod), loadBalancingMethodElement.Value, true));
                                    policyInstance.LoadBalancingMethod = loadBalancingMethodInstance;
                                }
                                
                                XElement endpointsSequenceElement = policyElement.Element(XName.Get("Endpoints", "http://schemas.microsoft.com/windowsazure"));
                                if (endpointsSequenceElement != null)
                                {
                                    foreach (XElement endpointsElement in endpointsSequenceElement.Elements(XName.Get("Endpoint", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        DefinitionEndpointResponse endpointInstance = new DefinitionEndpointResponse();
                                        policyInstance.Endpoints.Add(endpointInstance);
                                        
                                        XElement domainNameElement = endpointsElement.Element(XName.Get("DomainName", "http://schemas.microsoft.com/windowsazure"));
                                        if (domainNameElement != null)
                                        {
                                            string domainNameInstance = domainNameElement.Value;
                                            endpointInstance.DomainName = domainNameInstance;
                                        }
                                        
                                        XElement statusElement2 = endpointsElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                                        if (statusElement2 != null)
                                        {
                                            EndpointStatus statusInstance2 = ((EndpointStatus)Enum.Parse(typeof(EndpointStatus), statusElement2.Value, true));
                                            endpointInstance.Status = statusInstance2;
                                        }
                                        
                                        XElement typeElement = endpointsElement.Element(XName.Get("Type", "http://schemas.microsoft.com/windowsazure"));
                                        if (typeElement != null)
                                        {
                                            EndpointType typeInstance = ((EndpointType)Enum.Parse(typeof(EndpointType), typeElement.Value, true));
                                            endpointInstance.Type = typeInstance;
                                        }
                                        
                                        XElement locationElement = endpointsElement.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                                        if (locationElement != null)
                                        {
                                            string locationInstance = locationElement.Value;
                                            endpointInstance.Location = locationInstance;
                                        }
                                        
                                        XElement monitorStatusElement = endpointsElement.Element(XName.Get("MonitorStatus", "http://schemas.microsoft.com/windowsazure"));
                                        if (monitorStatusElement != null)
                                        {
                                            DefinitionEndpointMonitorStatus monitorStatusInstance = ((DefinitionEndpointMonitorStatus)Enum.Parse(typeof(DefinitionEndpointMonitorStatus), monitorStatusElement.Value, true));
                                            endpointInstance.MonitorStatus = monitorStatusInstance;
                                        }
                                        
                                        XElement weightElement = endpointsElement.Element(XName.Get("Weight", "http://schemas.microsoft.com/windowsazure"));
                                        if (weightElement != null)
                                        {
                                            int weightInstance = int.Parse(weightElement.Value, CultureInfo.InvariantCulture);
                                            endpointInstance.Weight = weightInstance;
                                        }
                                    }
                                }
                                
                                XElement monitorStatusElement2 = policyElement.Element(XName.Get("MonitorStatus", "http://schemas.microsoft.com/windowsazure"));
                                if (monitorStatusElement2 != null)
                                {
                                    DefinitionPolicyMonitorStatus monitorStatusInstance2 = ((DefinitionPolicyMonitorStatus)Enum.Parse(typeof(DefinitionPolicyMonitorStatus), monitorStatusElement2.Value, true));
                                    policyInstance.MonitorStatus = monitorStatusInstance2;
                                }
                            }
                        }
                    }
                    
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
    }
    
    /// <summary>
    /// The Traffic Manager API includes operations for managing Traffic
    /// Manager profiles.
    /// </summary>
    public partial interface IProfileOperations
    {
        /// <summary>
        /// The DNS name that you want to use. You must include
        /// .trafficmanager.net in the name.  (see
        /// http://msdn.microsoft.com/en-us/library/dn510368.aspx for more
        /// information)
        /// </summary>
        /// <param name='dnsName'>
        /// DNS name that you want to use
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response to the request for a listing of namespaces.
        /// </returns>
        Task<DnsPrefixAvailabilityCheckResponse> CheckDnsPrefixAvailabilityAsync(string dnsName, CancellationToken cancellationToken);
        
        /// <summary>
        /// Creates a new profile for a domain name, owned by the specified
        /// subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758254.aspx for more
        /// information)
        /// </summary>
        /// <param name='name'>
        /// The name of the profile.
        /// </param>
        /// <param name='domainName'>
        /// The name of the domain that the profile is being created for.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> CreateAsync(string name, string domainName, CancellationToken cancellationToken);
        
        /// <summary>
        /// Deletes a profile and all of its definitions. This operation cannot
        /// be reverted.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758256.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// The name of the profile.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> DeleteAsync(string profileName, CancellationToken cancellationToken);
        
        /// <summary>
        /// Returns profile details, including all definition versions and
        /// their statuses.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758248.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// The name of the profile.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Profile Details operation response.
        /// </returns>
        Task<ProfileGetResponse> GetAsync(string profileName, CancellationToken cancellationToken);
        
        /// <summary>
        /// Returns all profiles owned by a subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758249.aspx for more
        /// information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Profiles operation response.
        /// </returns>
        Task<ProfilesListResponse> ListAsync(CancellationToken cancellationToken);
        
        /// <summary>
        /// Enables or disables a profile.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758250.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// The name of the profile.
        /// </param>
        /// <param name='profileStatus'>
        /// Specifies whether the profile should be enabled or disabled.
        /// </param>
        /// <param name='definitionVersionNumber'>
        /// Version of the definition associated with the profile
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> UpdateAsync(string profileName, ProfileDefinitionStatus profileStatus, int definitionVersionNumber, CancellationToken cancellationToken);
    }
    
    /// <summary>
    /// The Traffic Manager API includes operations for managing Traffic
    /// Manager profiles.
    /// </summary>
    internal partial class ProfileOperations : IServiceOperations<TrafficManagerClient>, IProfileOperations
    {
        /// <summary>
        /// Initializes a new instance of the ProfileOperations class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        internal ProfileOperations(TrafficManagerClient client)
        {
            this._client = client;
        }
        
        private TrafficManagerClient _client;
        
        /// <summary>
        /// Gets a reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.TrafficManagerClient.
        /// </summary>
        public TrafficManagerClient Client
        {
            get { return this._client; }
        }
        
        /// <summary>
        /// The DNS name that you want to use. You must include
        /// .trafficmanager.net in the name.  (see
        /// http://msdn.microsoft.com/en-us/library/dn510368.aspx for more
        /// information)
        /// </summary>
        /// <param name='dnsName'>
        /// Required. DNS name that you want to use
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response to the request for a listing of namespaces.
        /// </returns>
        public async Task<DnsPrefixAvailabilityCheckResponse> CheckDnsPrefixAvailabilityAsync(string dnsName, CancellationToken cancellationToken)
        {
            // Validate
            if (dnsName == null)
            {
                throw new ArgumentNullException("dnsName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("dnsName", dnsName);
                Tracing.Enter(invocationId, this, "CheckDnsPrefixAvailabilityAsync", tracingParameters);
            }
            
            // Construct URL
            string baseUrl = this.Client.BaseUri.AbsoluteUri;
            string url = "/" + (this.Client.Credentials.SubscriptionId != null ? this.Client.Credentials.SubscriptionId.Trim() : "") + "/services/WATM/operations/isavailable/" + dnsName.Trim();
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2011-10-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.Create(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false), CloudExceptionType.Xml);
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    DnsPrefixAvailabilityCheckResponse result = null;
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    result = new DnsPrefixAvailabilityCheckResponse();
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement availabilityResponseElement = responseDoc.Element(XName.Get("AvailabilityResponse", "http://schemas.microsoft.com/windowsazure"));
                    if (availabilityResponseElement != null)
                    {
                        XElement resultElement = availabilityResponseElement.Element(XName.Get("Result", "http://schemas.microsoft.com/windowsazure"));
                        if (resultElement != null)
                        {
                            bool resultInstance = bool.Parse(resultElement.Value);
                            result.Result = resultInstance;
                        }
                    }
                    
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Creates a new profile for a domain name, owned by the specified
        /// subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758254.aspx for more
        /// information)
        /// </summary>
        /// <param name='name'>
        /// Required. The name of the profile.
        /// </param>
        /// <param name='domainName'>
        /// Required. The name of the domain that the profile is being created
        /// for.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> CreateAsync(string name, string domainName, CancellationToken cancellationToken)
        {
            // Validate
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (name.Length > 256)
            {
                throw new ArgumentOutOfRangeException("name");
            }
            if (domainName == null)
            {
                throw new ArgumentNullException("domainName");
            }
            if (domainName.Length > 253)
            {
                throw new ArgumentOutOfRangeException("domainName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("name", name);
                tracingParameters.Add("domainName", domainName);
                Tracing.Enter(invocationId, this, "CreateAsync", tracingParameters);
            }
            
            // Construct URL
            string baseUrl = this.Client.BaseUri.AbsoluteUri;
            string url = "/" + (this.Client.Credentials.SubscriptionId != null ? this.Client.Credentials.SubscriptionId.Trim() : "") + "/services/WATM/profiles";
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2011-10-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement profileElement = new XElement(XName.Get("Profile", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(profileElement);
                
                XElement domainNameElement = new XElement(XName.Get("DomainName", "http://schemas.microsoft.com/windowsazure"));
                domainNameElement.Value = domainName;
                profileElement.Add(domainNameElement);
                
                XElement nameElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                nameElement.Value = name;
                profileElement.Add(nameElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.Create(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false), CloudExceptionType.Xml);
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = null;
                    result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Deletes a profile and all of its definitions. This operation cannot
        /// be reverted.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758256.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// Required. The name of the profile.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> DeleteAsync(string profileName, CancellationToken cancellationToken)
        {
            // Validate
            if (profileName == null)
            {
                throw new ArgumentNullException("profileName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("profileName", profileName);
                Tracing.Enter(invocationId, this, "DeleteAsync", tracingParameters);
            }
            
            // Construct URL
            string baseUrl = this.Client.BaseUri.AbsoluteUri;
            string url = "/" + (this.Client.Credentials.SubscriptionId != null ? this.Client.Credentials.SubscriptionId.Trim() : "") + "/services/WATM/profiles/" + profileName.Trim();
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Delete;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2011-10-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.Create(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false), CloudExceptionType.Xml);
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = null;
                    result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Returns profile details, including all definition versions and
        /// their statuses.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758248.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// Required. The name of the profile.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Profile Details operation response.
        /// </returns>
        public async Task<ProfileGetResponse> GetAsync(string profileName, CancellationToken cancellationToken)
        {
            // Validate
            if (profileName == null)
            {
                throw new ArgumentNullException("profileName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("profileName", profileName);
                Tracing.Enter(invocationId, this, "GetAsync", tracingParameters);
            }
            
            // Construct URL
            string baseUrl = this.Client.BaseUri.AbsoluteUri;
            string url = "/" + (this.Client.Credentials.SubscriptionId != null ? this.Client.Credentials.SubscriptionId.Trim() : "") + "/services/WATM/profiles/" + profileName.Trim();
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2011-10-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.Create(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false), CloudExceptionType.Xml);
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    ProfileGetResponse result = null;
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    result = new ProfileGetResponse();
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement profileElement = responseDoc.Element(XName.Get("Profile", "http://schemas.microsoft.com/windowsazure"));
                    if (profileElement != null)
                    {
                        Profile profileInstance = new Profile();
                        result.Profile = profileInstance;
                        
                        XElement domainNameElement = profileElement.Element(XName.Get("DomainName", "http://schemas.microsoft.com/windowsazure"));
                        if (domainNameElement != null)
                        {
                            string domainNameInstance = domainNameElement.Value;
                            profileInstance.DomainName = domainNameInstance;
                        }
                        
                        XElement nameElement = profileElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        if (nameElement != null)
                        {
                            string nameInstance = nameElement.Value;
                            profileInstance.Name = nameInstance;
                        }
                        
                        XElement statusElement = profileElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                        if (statusElement != null)
                        {
                            ProfileDefinitionStatus statusInstance = ((ProfileDefinitionStatus)Enum.Parse(typeof(ProfileDefinitionStatus), statusElement.Value, true));
                            profileInstance.Status = statusInstance;
                        }
                        
                        XElement statusDetailsElement = profileElement.Element(XName.Get("StatusDetails", "http://schemas.microsoft.com/windowsazure"));
                        if (statusDetailsElement != null)
                        {
                            ProfileStatusDetails statusDetailsInstance = new ProfileStatusDetails();
                            profileInstance.StatusDetails = statusDetailsInstance;
                            
                            XElement enabledVersionElement = statusDetailsElement.Element(XName.Get("EnabledVersion", "http://schemas.microsoft.com/windowsazure"));
                            if (enabledVersionElement != null)
                            {
                                int enabledVersionInstance = int.Parse(enabledVersionElement.Value, CultureInfo.InvariantCulture);
                                statusDetailsInstance.EnabledDefinitionVersion = enabledVersionInstance;
                            }
                        }
                        
                        XElement definitionsSequenceElement = profileElement.Element(XName.Get("Definitions", "http://schemas.microsoft.com/windowsazure"));
                        if (definitionsSequenceElement != null)
                        {
                            foreach (XElement definitionsElement in definitionsSequenceElement.Elements(XName.Get("Definition", "http://schemas.microsoft.com/windowsazure")))
                            {
                                DefinitionStatusAndVersion definitionInstance = new DefinitionStatusAndVersion();
                                profileInstance.Definitions.Add(definitionInstance);
                                
                                XElement statusElement2 = definitionsElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                                if (statusElement2 != null)
                                {
                                    ProfileDefinitionStatus statusInstance2 = ((ProfileDefinitionStatus)Enum.Parse(typeof(ProfileDefinitionStatus), statusElement2.Value, true));
                                    definitionInstance.Status = statusInstance2;
                                }
                                
                                XElement versionElement = definitionsElement.Element(XName.Get("Version", "http://schemas.microsoft.com/windowsazure"));
                                if (versionElement != null)
                                {
                                    int versionInstance = int.Parse(versionElement.Value, CultureInfo.InvariantCulture);
                                    definitionInstance.Version = versionInstance;
                                }
                            }
                        }
                    }
                    
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Returns all profiles owned by a subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758249.aspx for more
        /// information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Profiles operation response.
        /// </returns>
        public async Task<ProfilesListResponse> ListAsync(CancellationToken cancellationToken)
        {
            // Validate
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                Tracing.Enter(invocationId, this, "ListAsync", tracingParameters);
            }
            
            // Construct URL
            string baseUrl = this.Client.BaseUri.AbsoluteUri;
            string url = "/" + (this.Client.Credentials.SubscriptionId != null ? this.Client.Credentials.SubscriptionId.Trim() : "") + "/services/WATM/profiles";
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2011-10-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.Create(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false), CloudExceptionType.Xml);
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    ProfilesListResponse result = null;
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    result = new ProfilesListResponse();
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement profilesSequenceElement = responseDoc.Element(XName.Get("Profiles", "http://schemas.microsoft.com/windowsazure"));
                    if (profilesSequenceElement != null)
                    {
                        foreach (XElement profilesElement in profilesSequenceElement.Elements(XName.Get("Profile", "http://schemas.microsoft.com/windowsazure")))
                        {
                            Profile profileInstance = new Profile();
                            result.Profiles.Add(profileInstance);
                            
                            XElement domainNameElement = profilesElement.Element(XName.Get("DomainName", "http://schemas.microsoft.com/windowsazure"));
                            if (domainNameElement != null)
                            {
                                string domainNameInstance = domainNameElement.Value;
                                profileInstance.DomainName = domainNameInstance;
                            }
                            
                            XElement nameElement = profilesElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                            if (nameElement != null)
                            {
                                string nameInstance = nameElement.Value;
                                profileInstance.Name = nameInstance;
                            }
                            
                            XElement statusElement = profilesElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                            if (statusElement != null)
                            {
                                ProfileDefinitionStatus statusInstance = ((ProfileDefinitionStatus)Enum.Parse(typeof(ProfileDefinitionStatus), statusElement.Value, true));
                                profileInstance.Status = statusInstance;
                            }
                            
                            XElement statusDetailsElement = profilesElement.Element(XName.Get("StatusDetails", "http://schemas.microsoft.com/windowsazure"));
                            if (statusDetailsElement != null)
                            {
                                ProfileStatusDetails statusDetailsInstance = new ProfileStatusDetails();
                                profileInstance.StatusDetails = statusDetailsInstance;
                                
                                XElement enabledVersionElement = statusDetailsElement.Element(XName.Get("EnabledVersion", "http://schemas.microsoft.com/windowsazure"));
                                if (enabledVersionElement != null)
                                {
                                    int enabledVersionInstance = int.Parse(enabledVersionElement.Value, CultureInfo.InvariantCulture);
                                    statusDetailsInstance.EnabledDefinitionVersion = enabledVersionInstance;
                                }
                            }
                            
                            XElement definitionsSequenceElement = profilesElement.Element(XName.Get("Definitions", "http://schemas.microsoft.com/windowsazure"));
                            if (definitionsSequenceElement != null)
                            {
                                foreach (XElement definitionsElement in definitionsSequenceElement.Elements(XName.Get("Definition", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    DefinitionStatusAndVersion definitionInstance = new DefinitionStatusAndVersion();
                                    profileInstance.Definitions.Add(definitionInstance);
                                    
                                    XElement statusElement2 = definitionsElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                                    if (statusElement2 != null)
                                    {
                                        ProfileDefinitionStatus statusInstance2 = ((ProfileDefinitionStatus)Enum.Parse(typeof(ProfileDefinitionStatus), statusElement2.Value, true));
                                        definitionInstance.Status = statusInstance2;
                                    }
                                    
                                    XElement versionElement = definitionsElement.Element(XName.Get("Version", "http://schemas.microsoft.com/windowsazure"));
                                    if (versionElement != null)
                                    {
                                        int versionInstance = int.Parse(versionElement.Value, CultureInfo.InvariantCulture);
                                        definitionInstance.Version = versionInstance;
                                    }
                                }
                            }
                        }
                    }
                    
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Enables or disables a profile.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758250.aspx for more
        /// information)
        /// </summary>
        /// <param name='profileName'>
        /// Required. The name of the profile.
        /// </param>
        /// <param name='profileStatus'>
        /// Required. Specifies whether the profile should be enabled or
        /// disabled.
        /// </param>
        /// <param name='definitionVersionNumber'>
        /// Required. Version of the definition associated with the profile
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> UpdateAsync(string profileName, ProfileDefinitionStatus profileStatus, int definitionVersionNumber, CancellationToken cancellationToken)
        {
            // Validate
            if (profileName == null)
            {
                throw new ArgumentNullException("profileName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("profileName", profileName);
                tracingParameters.Add("profileStatus", profileStatus);
                tracingParameters.Add("definitionVersionNumber", definitionVersionNumber);
                Tracing.Enter(invocationId, this, "UpdateAsync", tracingParameters);
            }
            
            // Construct URL
            string baseUrl = this.Client.BaseUri.AbsoluteUri;
            string url = "/" + (this.Client.Credentials.SubscriptionId != null ? this.Client.Credentials.SubscriptionId.Trim() : "") + "/services/WATM/profiles/" + profileName.Trim();
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Put;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2011-10-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement profileElement = new XElement(XName.Get("Profile", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(profileElement);
                
                XElement statusElement = new XElement(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                statusElement.Value = profileStatus.ToString();
                profileElement.Add(statusElement);
                
                XElement statusDetailsElement = new XElement(XName.Get("StatusDetails", "http://schemas.microsoft.com/windowsazure"));
                profileElement.Add(statusDetailsElement);
                
                XElement enabledVersionElement = new XElement(XName.Get("EnabledVersion", "http://schemas.microsoft.com/windowsazure"));
                enabledVersionElement.Value = definitionVersionNumber.ToString();
                statusDetailsElement.Add(enabledVersionElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.Create(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false), CloudExceptionType.Xml);
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = null;
                    result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
    }
}

namespace Microsoft.WindowsAzure
{
    /// <summary>
    /// The Windows Azure Traffic Manager management API provides a RESTful set
    /// of web services that interact with Windows Azure Traffic Manager
    /// service for creating, updating, listing, and deleting Traffic Manager
    /// profiles and definitions.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/dn166981.aspx for
    /// more information)
    /// </summary>
    public static partial class TrafficManagerClientExtensions
    {
    }
}

namespace Microsoft.WindowsAzure
{
    /// <summary>
    /// The Windows Azure Traffic Manager management API provides a RESTful set
    /// of web services that interact with Windows Azure Traffic Manager
    /// service for creating, updating, listing, and deleting Traffic Manager
    /// profiles and definitions.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/dn166981.aspx for
    /// more information)
    /// </summary>
    public static partial class DefinitionOperationsExtensions
    {
        /// <summary>
        /// Creates a new definition for a specified profile.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758257.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IDefinitionOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile to create a new definition for.
        /// </param>
        /// <param name='parameters'>
        /// Required. Parameters supplied to the Create Definition operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse Create(this IDefinitionOperations operations, string profileName, DefinitionCreateParameters parameters)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IDefinitionOperations)s).CreateAsync(profileName, parameters);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <summary>
        /// Creates a new definition for a specified profile.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758257.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IDefinitionOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile to create a new definition for.
        /// </param>
        /// <param name='parameters'>
        /// Required. Parameters supplied to the Create Definition operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> CreateAsync(this IDefinitionOperations operations, string profileName, DefinitionCreateParameters parameters)
        {
            return operations.CreateAsync(profileName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// Returns an existing profile definition.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758248.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IDefinitionOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile to get definition from.
        /// </param>
        /// <returns>
        /// The Get Definition operation response.
        /// </returns>
        public static DefinitionGetResponse Get(this IDefinitionOperations operations, string profileName)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IDefinitionOperations)s).GetAsync(profileName);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <summary>
        /// Returns an existing profile definition.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758248.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IDefinitionOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile to get definition from.
        /// </param>
        /// <returns>
        /// The Get Definition operation response.
        /// </returns>
        public static Task<DefinitionGetResponse> GetAsync(this IDefinitionOperations operations, string profileName)
        {
            return operations.GetAsync(profileName, CancellationToken.None);
        }
        
        /// <summary>
        /// Returns all definitions of a profile  (see
        /// http://msdn.microsoft.com/en-us/library/hh758252.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IDefinitionOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile to return all definitions
        /// </param>
        /// <returns>
        /// The List Definitions operation response.
        /// </returns>
        public static DefinitionsListResponse List(this IDefinitionOperations operations, string profileName)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IDefinitionOperations)s).ListAsync(profileName);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <summary>
        /// Returns all definitions of a profile  (see
        /// http://msdn.microsoft.com/en-us/library/hh758252.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IDefinitionOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile to return all definitions
        /// </param>
        /// <returns>
        /// The List Definitions operation response.
        /// </returns>
        public static Task<DefinitionsListResponse> ListAsync(this IDefinitionOperations operations, string profileName)
        {
            return operations.ListAsync(profileName, CancellationToken.None);
        }
    }
}

namespace Microsoft.WindowsAzure
{
    /// <summary>
    /// The Windows Azure Traffic Manager management API provides a RESTful set
    /// of web services that interact with Windows Azure Traffic Manager
    /// service for creating, updating, listing, and deleting Traffic Manager
    /// profiles and definitions.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/dn166981.aspx for
    /// more information)
    /// </summary>
    public static partial class ProfileOperationsExtensions
    {
        /// <summary>
        /// The DNS name that you want to use. You must include
        /// .trafficmanager.net in the name.  (see
        /// http://msdn.microsoft.com/en-us/library/dn510368.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <param name='dnsName'>
        /// Required. DNS name that you want to use
        /// </param>
        /// <returns>
        /// The response to the request for a listing of namespaces.
        /// </returns>
        public static DnsPrefixAvailabilityCheckResponse CheckDnsPrefixAvailability(this IProfileOperations operations, string dnsName)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IProfileOperations)s).CheckDnsPrefixAvailabilityAsync(dnsName);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <summary>
        /// The DNS name that you want to use. You must include
        /// .trafficmanager.net in the name.  (see
        /// http://msdn.microsoft.com/en-us/library/dn510368.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <param name='dnsName'>
        /// Required. DNS name that you want to use
        /// </param>
        /// <returns>
        /// The response to the request for a listing of namespaces.
        /// </returns>
        public static Task<DnsPrefixAvailabilityCheckResponse> CheckDnsPrefixAvailabilityAsync(this IProfileOperations operations, string dnsName)
        {
            return operations.CheckDnsPrefixAvailabilityAsync(dnsName, CancellationToken.None);
        }
        
        /// <summary>
        /// Creates a new profile for a domain name, owned by the specified
        /// subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758254.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <param name='name'>
        /// Required. The name of the profile.
        /// </param>
        /// <param name='domainName'>
        /// Required. The name of the domain that the profile is being created
        /// for.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse Create(this IProfileOperations operations, string name, string domainName)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IProfileOperations)s).CreateAsync(name, domainName);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <summary>
        /// Creates a new profile for a domain name, owned by the specified
        /// subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758254.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <param name='name'>
        /// Required. The name of the profile.
        /// </param>
        /// <param name='domainName'>
        /// Required. The name of the domain that the profile is being created
        /// for.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> CreateAsync(this IProfileOperations operations, string name, string domainName)
        {
            return operations.CreateAsync(name, domainName, CancellationToken.None);
        }
        
        /// <summary>
        /// Deletes a profile and all of its definitions. This operation cannot
        /// be reverted.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758256.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse Delete(this IProfileOperations operations, string profileName)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IProfileOperations)s).DeleteAsync(profileName);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <summary>
        /// Deletes a profile and all of its definitions. This operation cannot
        /// be reverted.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758256.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> DeleteAsync(this IProfileOperations operations, string profileName)
        {
            return operations.DeleteAsync(profileName, CancellationToken.None);
        }
        
        /// <summary>
        /// Returns profile details, including all definition versions and
        /// their statuses.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758248.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile.
        /// </param>
        /// <returns>
        /// The Get Profile Details operation response.
        /// </returns>
        public static ProfileGetResponse Get(this IProfileOperations operations, string profileName)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IProfileOperations)s).GetAsync(profileName);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <summary>
        /// Returns profile details, including all definition versions and
        /// their statuses.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758248.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile.
        /// </param>
        /// <returns>
        /// The Get Profile Details operation response.
        /// </returns>
        public static Task<ProfileGetResponse> GetAsync(this IProfileOperations operations, string profileName)
        {
            return operations.GetAsync(profileName, CancellationToken.None);
        }
        
        /// <summary>
        /// Returns all profiles owned by a subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758249.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <returns>
        /// The List Profiles operation response.
        /// </returns>
        public static ProfilesListResponse List(this IProfileOperations operations)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IProfileOperations)s).ListAsync();
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <summary>
        /// Returns all profiles owned by a subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758249.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <returns>
        /// The List Profiles operation response.
        /// </returns>
        public static Task<ProfilesListResponse> ListAsync(this IProfileOperations operations)
        {
            return operations.ListAsync(CancellationToken.None);
        }
        
        /// <summary>
        /// Enables or disables a profile.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758250.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile.
        /// </param>
        /// <param name='profileStatus'>
        /// Required. Specifies whether the profile should be enabled or
        /// disabled.
        /// </param>
        /// <param name='definitionVersionNumber'>
        /// Required. Version of the definition associated with the profile
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse Update(this IProfileOperations operations, string profileName, ProfileDefinitionStatus profileStatus, int definitionVersionNumber)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IProfileOperations)s).UpdateAsync(profileName, profileStatus, definitionVersionNumber);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <summary>
        /// Enables or disables a profile.  (see
        /// http://msdn.microsoft.com/en-us/library/hh758250.aspx for more
        /// information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.TrafficManager.IProfileOperations.
        /// </param>
        /// <param name='profileName'>
        /// Required. The name of the profile.
        /// </param>
        /// <param name='profileStatus'>
        /// Required. Specifies whether the profile should be enabled or
        /// disabled.
        /// </param>
        /// <param name='definitionVersionNumber'>
        /// Required. Version of the definition associated with the profile
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> UpdateAsync(this IProfileOperations operations, string profileName, ProfileDefinitionStatus profileStatus, int definitionVersionNumber)
        {
            return operations.UpdateAsync(profileName, profileStatus, definitionVersionNumber, CancellationToken.None);
        }
    }
}
